// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const getAllDEPNames = `-- name: GetAllDEPNames :many
SELECT name FROM dep_names WHERE tokenpki_staging_cert_pem IS NOT NULL LIMIT ? OFFSET ?
`

type GetAllDEPNamesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllDEPNames(ctx context.Context, arg GetAllDEPNamesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllDEPNames, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssignerProfile = `-- name: GetAssignerProfile :one
SELECT
  assigner_profile_uuid,
  assigner_profile_uuid_at
FROM
  dep_names
WHERE
  name = ?
`

type GetAssignerProfileRow struct {
	AssignerProfileUuid   sql.NullString
	AssignerProfileUuidAt sql.NullString
}

func (q *Queries) GetAssignerProfile(ctx context.Context, name string) (GetAssignerProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getAssignerProfile, name)
	var i GetAssignerProfileRow
	err := row.Scan(&i.AssignerProfileUuid, &i.AssignerProfileUuidAt)
	return i, err
}

const getAuthTokens = `-- name: GetAuthTokens :one
SELECT
  consumer_key,
  consumer_secret,
  access_token,
  access_secret,
  access_token_expiry
FROM
  dep_names
WHERE
  name = ?
`

type GetAuthTokensRow struct {
	ConsumerKey       sql.NullString
	ConsumerSecret    sql.NullString
	AccessToken       sql.NullString
	AccessSecret      sql.NullString
	AccessTokenExpiry sql.NullString
}

func (q *Queries) GetAuthTokens(ctx context.Context, name string) (GetAuthTokensRow, error) {
	row := q.db.QueryRowContext(ctx, getAuthTokens, name)
	var i GetAuthTokensRow
	err := row.Scan(
		&i.ConsumerKey,
		&i.ConsumerSecret,
		&i.AccessToken,
		&i.AccessSecret,
		&i.AccessTokenExpiry,
	)
	return i, err
}

const getConfigBaseURL = `-- name: GetConfigBaseURL :one
SELECT config_base_url FROM dep_names WHERE name = ?
`

func (q *Queries) GetConfigBaseURL(ctx context.Context, name string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getConfigBaseURL, name)
	var config_base_url sql.NullString
	err := row.Scan(&config_base_url)
	return config_base_url, err
}

const getCurrentKeypair = `-- name: GetCurrentKeypair :one
SELECT
  tokenpki_cert_pem,
  tokenpki_key_pem
FROM
  dep_names
WHERE
  name = ?
`

type GetCurrentKeypairRow struct {
	TokenpkiCertPem []byte
	TokenpkiKeyPem  []byte
}

func (q *Queries) GetCurrentKeypair(ctx context.Context, name string) (GetCurrentKeypairRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentKeypair, name)
	var i GetCurrentKeypairRow
	err := row.Scan(&i.TokenpkiCertPem, &i.TokenpkiKeyPem)
	return i, err
}

const getDEPNames = `-- name: GetDEPNames :many
SELECT
  name
FROM
  dep_names
WHERE
  name IN (/*SLICE:dep_names*/?) AND
  tokenpki_staging_cert_pem IS NOT NULL
LIMIT ? OFFSET ?
`

type GetDEPNamesParams struct {
	DepNames []string
	Limit    int32
	Offset   int32
}

func (q *Queries) GetDEPNames(ctx context.Context, arg GetDEPNamesParams) ([]string, error) {
	query := getDEPNames
	var queryParams []interface{}
	if len(arg.DepNames) > 0 {
		for _, v := range arg.DepNames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:dep_names*/?", strings.Repeat(",?", len(arg.DepNames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:dep_names*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStagingKeypair = `-- name: GetStagingKeypair :one
SELECT
  tokenpki_staging_cert_pem,
  tokenpki_staging_key_pem
FROM
  dep_names
WHERE
  name = ?
`

type GetStagingKeypairRow struct {
	TokenpkiStagingCertPem []byte
	TokenpkiStagingKeyPem  []byte
}

func (q *Queries) GetStagingKeypair(ctx context.Context, name string) (GetStagingKeypairRow, error) {
	row := q.db.QueryRowContext(ctx, getStagingKeypair, name)
	var i GetStagingKeypairRow
	err := row.Scan(&i.TokenpkiStagingCertPem, &i.TokenpkiStagingKeyPem)
	return i, err
}

const getSyncerCursor = `-- name: GetSyncerCursor :one
SELECT syncer_cursor FROM dep_names WHERE name = ?
`

func (q *Queries) GetSyncerCursor(ctx context.Context, name string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getSyncerCursor, name)
	var syncer_cursor sql.NullString
	err := row.Scan(&syncer_cursor)
	return syncer_cursor, err
}

const upstageKeypair = `-- name: UpstageKeypair :exec
UPDATE
  dep_names
SET
  tokenpki_cert_pem = tokenpki_staging_cert_pem,
  tokenpki_key_pem = tokenpki_staging_key_pem
WHERE
  name = ?
`

func (q *Queries) UpstageKeypair(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, upstageKeypair, name)
	return err
}
